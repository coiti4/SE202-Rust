# [doc = r" The RTIC application module"] pub mod app {# [doc = r" Always include the device crate which contains the vector table"] use pac as you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml ; pub use rtic :: Monotonic as _ ; # [doc = r" Holds static methods for each monotonic."] pub mod monotonics {pub use MyMonotonic :: now ; # [doc = "This module holds the static implementation for `MyMonotonic::now()`"] # [allow (non_snake_case)] pub mod MyMonotonic {# [doc = r" Read the current time from this monotonic"] pub fn now () -> < super :: super :: MyMonotonic as rtic :: Monotonic > :: Instant {rtic :: export :: interrupt :: free (| _ | {use rtic :: Monotonic as _ ; if let Some (m) = unsafe {& mut * super :: super :: __rtic_internal_MONOTONIC_STORAGE_MyMonotonic . get_mut ()} {m . now ()} else {< super :: super :: MyMonotonic as rtic :: Monotonic > :: zero ()}})}}} use core :: mem :: MaybeUninit ; use stm32l4xx_hal :: device :: {USART1} ; use super :: * ; # [doc = r" User code from within the module"] type MyMonotonic = DwtSystick < 80_000_000 > ; type Instant = < MyMonotonic as rtic :: Monotonic > :: Instant ; # [doc = r" User code end"] # [doc = " User provided init function"] # [inline (always)] # [allow (non_snake_case)] fn init (cx : init :: Context) -> (Shared , Local , init :: Monotonics) {defmt :: info ! ("Starting dfmt initialization") ; let mut cp = cx . core ; let dp = cx . device ; let mut mono = DwtSystick :: new (& mut cp . DCB , cp . DWT , cp . SYST , 80_000_000) ; let mut rcc = dp . RCC . constrain () ; let mut flash = dp . FLASH . constrain () ; let mut pwr = dp . PWR . constrain (& mut rcc . apb1r1) ; let clocks = rcc . cfgr . sysclk (80 . MHz ()) . freeze (& mut flash . acr , & mut pwr) ; let mut gpioa = dp . GPIOA . split (& mut rcc . ahb2) ; let mut gpiob = dp . GPIOB . split (& mut rcc . ahb2) ; let mut gpioc = dp . GPIOC . split (& mut rcc . ahb2) ; let tx_pin = gpiob . pb6 . into_alternate :: < 7 > (& mut gpiob . moder , & mut gpiob . otyper , & mut gpiob . afrl) ; let rx_pin = gpiob . pb7 . into_alternate :: < 7 > (& mut gpiob . moder , & mut gpiob . otyper , & mut gpiob . afrl) ; let config = Config :: default () ; let config = config . baudrate (38400 . bps ()) ; let mut serial = Serial :: usart1 (dp . USART1 , (tx_pin , rx_pin) , config , clocks , & mut rcc . apb2 ,) ; serial . listen (Event :: Rxne) ; let (_ , usart1_rx) = serial . split () ; let matrix = Matrix :: new (gpioa . pa2 , gpioa . pa3 , gpioa . pa4 , gpioa . pa5 , gpioa . pa6 , gpioa . pa7 , gpioa . pa15 , gpiob . pb0 , gpiob . pb1 , gpiob . pb2 , gpioc . pc3 , gpioc . pc4 , gpioc . pc5 , & mut gpioa . moder , & mut gpioa . otyper , & mut gpiob . moder , & mut gpiob . otyper , & mut gpioc . moder , & mut gpioc . otyper , clocks ,) ; defmt :: info ! ("Finishing dfmt initialization") ; display :: spawn (mono . now ()) . unwrap () ; defmt :: info ! ("Display function spawned") ; let pool : Pool < Image > = Pool :: new () ; unsafe {static mut MEMORY : MaybeUninit < [Node < Image > ; 3] > = MaybeUninit :: uninit () ; pool . grow_exact (& mut MEMORY) ;} let current_image = pool . alloc () . unwrap () . init (Image :: default ()) ; let rx_image = pool . alloc () . unwrap () . init (Image :: default ()) ; let next_image = None ; let changes = 0 ; screensaver :: spawn (mono . now ()) . unwrap () ; (Shared {next_image , pool , changes} , Local {matrix , usart1_rx , current_image , rx_image} , init :: Monotonics (mono))} # [doc = " User provided idle function"] # [allow (non_snake_case)] fn idle (_ : idle :: Context) -> ! {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; loop {}} # [doc = " User HW task: receive_byte"] # [allow (non_snake_case)] fn receive_byte (mut cx : receive_byte :: Context) {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; let next_pos : & mut usize = cx . local . next_pos ; let rx_image : & mut Image = cx . local . rx_image ; let pool = cx . shared . pool ; if let Ok (b) = cx . local . usart1_rx . read () {let mut start = false ; if b == 0xff {start = true ;} ; if * next_pos > 0 {rx_image . as_mut () [* next_pos - 1] = b ; * next_pos += 1 ;} else if start {* next_pos += 1 ;} ; if * next_pos == 8 * 8 * 3 + 1 {cx . shared . next_image . lock (| next_image | {if next_image . is_some () {let image = next_image . take () . unwrap () ; pool . free (image) ;} ; let mut future_image = pool . alloc () . unwrap () . init (Image :: default ()) ; swap (rx_image , & mut future_image) ; swap (next_image , Some (future_image) . borrow_mut ()) ; * next_pos = 0 ; notice_change :: spawn () . unwrap () ;}) ;}}} # [doc = " User SW task display"] # [allow (non_snake_case)] fn display (mut cx : display :: Context , at : Instant) {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; let matrix = cx . local . matrix ; let current_image = cx . local . current_image ; let next_row = cx . local . next_line ; let pool = cx . shared . pool ; matrix . send_row (* next_row , current_image . row (* next_row)) ; if * next_row == 7 {cx . shared . next_image . lock (| next_image | {if next_image . is_some () {let mut image = next_image . take () . unwrap () ; swap (current_image , & mut image) ; pool . free (image) ;}}) ;} ; * next_row = (* next_row + 1) % 8 ; let next = at + 1 . secs () / (8 * 60) ; display :: spawn_at (next , next) . unwrap () ;} # [doc = " User SW task screensaver"] # [allow (non_snake_case)] fn screensaver (cx : screensaver :: Context , at : Instant) {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; let last_changes = cx . local . last_changes ; let offset = cx . local . offset ; let pool = cx . shared . pool ; (cx . shared . changes , cx . shared . next_image) . lock (| changes , next_image | {if * last_changes == * changes {if next_image . is_some () {pool . free (next_image . take () . unwrap ()) ;} ; let text = Text :: new ("Hola Mundo!" , Point :: new (* offset , 7) , MonoTextStyle :: new (& IBM437_8X8_REGULAR , Rgb888 :: RED) ,) ; let mut image = Image :: default () ; text . draw (& mut image) . unwrap () ; let screensaver_image = pool . alloc () . unwrap () . init (image) ; swap (next_image , Some (screensaver_image) . borrow_mut ()) ; if * offset > - 120 {* offset -= 1 ;} else {* offset = 30 ;}} else {* last_changes = * changes ; * offset = 30 ;}}) ; let next : Instant = at + 60 . millis () ; screensaver :: spawn_at (next , next) . unwrap () ;} # [doc = " User SW task notice_change"] # [allow (non_snake_case)] fn notice_change (mut cx : notice_change :: Context) {use rtic :: Mutex as _ ; use rtic :: mutex :: prelude :: * ; cx . shared . changes . lock (| changes | {* changes = changes . wrapping_add (1) ;}) ;} # [doc = " RTIC shared resource struct"] struct Shared {next_image : Option < Box < Image > > , pool : Pool < Image > , changes : u32 ,} # [doc = " RTIC local resource struct"] struct Local {matrix : Matrix , usart1_rx : Rx < USART1 > , current_image : Box < Image > , rx_image : Box < Image > ,} # [doc = r" Monotonics used by the system"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_Monotonics (pub DwtSystick < 80_000_000 >) ; # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_init_Context < 'a > {# [doc = r" Core (Cortex-M) peripherals"] pub core : rtic :: export :: Peripherals , # [doc = r" Device peripherals"] pub device : pac :: Peripherals , # [doc = r" Critical section token for init"] pub cs : rtic :: export :: CriticalSection < 'a > ,} impl < 'a > __rtic_internal_init_Context < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (core : rtic :: export :: Peripherals ,) -> Self {__rtic_internal_init_Context {device : pac :: Peripherals :: steal () , cs : rtic :: export :: CriticalSection :: new () , core ,}}} # [allow (non_snake_case)] # [doc = " Initialization function"] pub mod init {# [doc (inline)] pub use super :: __rtic_internal_Monotonics as Monotonics ; # [doc (inline)] pub use super :: __rtic_internal_init_Context as Context ;} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_idle_Context < > {} impl < > __rtic_internal_idle_Context < > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & rtic :: export :: Priority) -> Self {__rtic_internal_idle_Context {}}} # [allow (non_snake_case)] # [doc = " Idle loop"] pub mod idle {# [doc (inline)] pub use super :: __rtic_internal_idle_Context as Context ;} mod shared_resources {use rtic :: export :: Priority ; # [doc (hidden)] # [allow (non_camel_case_types)] pub struct next_image_that_needs_to_be_locked < 'a > {priority : & 'a Priority ,} impl < 'a > next_image_that_needs_to_be_locked < 'a > {# [inline (always)] pub unsafe fn new (priority : & 'a Priority) -> Self {next_image_that_needs_to_be_locked {priority}} # [inline (always)] pub unsafe fn priority (& self) -> & Priority {self . priority}} # [doc (hidden)] # [allow (non_camel_case_types)] pub struct pool_that_needs_to_be_locked < 'a > {priority : & 'a Priority ,} impl < 'a > pool_that_needs_to_be_locked < 'a > {# [inline (always)] pub unsafe fn new (priority : & 'a Priority) -> Self {pool_that_needs_to_be_locked {priority}} # [inline (always)] pub unsafe fn priority (& self) -> & Priority {self . priority}} # [doc (hidden)] # [allow (non_camel_case_types)] pub struct changes_that_needs_to_be_locked < 'a > {priority : & 'a Priority ,} impl < 'a > changes_that_needs_to_be_locked < 'a > {# [inline (always)] pub unsafe fn new (priority : & 'a Priority) -> Self {changes_that_needs_to_be_locked {priority}} # [inline (always)] pub unsafe fn priority (& self) -> & Priority {self . priority}}} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = " Local resources `receive_byte` has access to"] pub struct __rtic_internal_receive_byteLocalResources < 'a > {# [doc = " Local resource `usart1_rx`"] pub usart1_rx : & 'a mut Rx < USART1 > , # [doc = " Local resource `rx_image`"] pub rx_image : & 'a mut Box < Image > , # [doc = " Local resource `next_pos`"] pub next_pos : & 'a mut usize ,} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = " Shared resources `receive_byte` has access to"] pub struct __rtic_internal_receive_byteSharedResources < 'a > {# [doc = " Resource proxy resource `next_image`. Use method `.lock()` to gain access"] pub next_image : shared_resources :: next_image_that_needs_to_be_locked < 'a > , # [doc = " Shared resource `pool`"] pub pool : & 'a Pool < Image > ,} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_receive_byte_Context < 'a > {# [doc = r" Local Resources this task has access to"] pub local : receive_byte :: LocalResources < 'a > , # [doc = r" Shared Resources this task has access to"] pub shared : receive_byte :: SharedResources < 'a > ,} impl < 'a > __rtic_internal_receive_byte_Context < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_receive_byte_Context {local : receive_byte :: LocalResources :: new () , shared : receive_byte :: SharedResources :: new (priority) ,}}} # [allow (non_snake_case)] # [doc = " Hardware task"] pub mod receive_byte {# [doc (inline)] pub use super :: __rtic_internal_receive_byteLocalResources as LocalResources ; # [doc (inline)] pub use super :: __rtic_internal_receive_byteSharedResources as SharedResources ; # [doc (inline)] pub use super :: __rtic_internal_receive_byte_Context as Context ;} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = " Local resources `display` has access to"] pub struct __rtic_internal_displayLocalResources < 'a > {# [doc = " Local resource `matrix`"] pub matrix : & 'a mut Matrix , # [doc = " Local resource `current_image`"] pub current_image : & 'a mut Box < Image > , # [doc = " Local resource `next_line`"] pub next_line : & 'a mut usize ,} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = " Shared resources `display` has access to"] pub struct __rtic_internal_displaySharedResources < 'a > {# [doc = " Resource proxy resource `next_image`. Use method `.lock()` to gain access"] pub next_image : shared_resources :: next_image_that_needs_to_be_locked < 'a > , # [doc = " Shared resource `pool`"] pub pool : & 'a Pool < Image > ,} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_display_Context < 'a > {# [doc = r" Local Resources this task has access to"] pub local : display :: LocalResources < 'a > , # [doc = r" Shared Resources this task has access to"] pub shared : display :: SharedResources < 'a > ,} impl < 'a > __rtic_internal_display_Context < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_display_Context {local : display :: LocalResources :: new () , shared : display :: SharedResources :: new (priority) ,}}} # [doc = r" Spawns the task directly"] pub fn __rtic_internal_display_spawn (_0 : Instant ,) -> Result < () , Instant > {let input = _0 ; unsafe {if let Some (index) = rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_display_FQ . get_mut ()) . dequeue ()) {(& mut * __rtic_internal_display_INPUTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (input) ; rtic :: export :: interrupt :: free (| _ | {(& mut * __rtic_internal_P2_RQ . get_mut ()) . enqueue_unchecked ((P2_T :: display , index)) ;}) ; rtic :: pend (pac :: interrupt :: USART2) ; Ok (())} else {Err (input)}}} # [doc (hidden)] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_display_MyMonotonic_SpawnHandle {# [doc (hidden)] marker : u32 ,} impl core :: fmt :: Debug for __rtic_internal_display_MyMonotonic_SpawnHandle {# [doc (hidden)] fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result {f . debug_struct ("MyMonotonic::SpawnHandle") . finish ()}} impl __rtic_internal_display_MyMonotonic_SpawnHandle {pub fn cancel (self) -> Result < Instant , () > {rtic :: export :: interrupt :: free (| _ | unsafe {let tq = & mut * __rtic_internal_TQ_MyMonotonic . get_mut () ; if let Some ((_task , index)) = tq . cancel_marker (self . marker) {let msg = (& * __rtic_internal_display_INPUTS . get ()) . get_unchecked (usize :: from (index)) . as_ptr () . read () ; (& mut * __rtic_internal_display_FQ . get_mut ()) . split () . 0 . enqueue_unchecked (index) ; Ok (msg)} else {Err (())}})} # [doc = r" Reschedule after "] # [inline] pub fn reschedule_after (self , duration : < MyMonotonic as rtic :: Monotonic > :: Duration) -> Result < Self , () > {self . reschedule_at (monotonics :: MyMonotonic :: now () + duration)} # [doc = r" Reschedule at "] pub fn reschedule_at (self , instant : < MyMonotonic as rtic :: Monotonic > :: Instant) -> Result < Self , () > {rtic :: export :: interrupt :: free (| _ | unsafe {let marker = __rtic_internal_TIMER_QUEUE_MARKER . get () . read () ; __rtic_internal_TIMER_QUEUE_MARKER . get_mut () . write (marker . wrapping_add (1)) ; let tq = (& mut * __rtic_internal_TQ_MyMonotonic . get_mut ()) ; tq . update_marker (self . marker , marker , instant , || rtic :: export :: SCB :: set_pendst ()) . map (| _ | display :: MyMonotonic :: SpawnHandle {marker})})}} # [doc = r" Spawns the task after a set duration relative to the current time"] # [doc = r""] # [doc = r" This will use the time `Instant::new(0)` as baseline if called in `#[init]`,"] # [doc = r" so if you use a non-resetable timer use `spawn_at` when in `#[init]`"] # [allow (non_snake_case)] pub fn __rtic_internal_display_MyMonotonic_spawn_after (duration : < MyMonotonic as rtic :: Monotonic > :: Duration , _0 : Instant) -> Result < display :: MyMonotonic :: SpawnHandle , Instant > {let instant = monotonics :: MyMonotonic :: now () ; __rtic_internal_display_MyMonotonic_spawn_at (instant + duration , _0)} # [doc = r" Spawns the task at a fixed time instant"] # [allow (non_snake_case)] pub fn __rtic_internal_display_MyMonotonic_spawn_at (instant : < MyMonotonic as rtic :: Monotonic > :: Instant , _0 : Instant) -> Result < display :: MyMonotonic :: SpawnHandle , Instant > {unsafe {let input = _0 ; if let Some (index) = rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_display_FQ . get_mut ()) . dequeue ()) {(& mut * __rtic_internal_display_INPUTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (input) ; (& mut * __rtic_internal_display_MyMonotonic_INSTANTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (instant) ; rtic :: export :: interrupt :: free (| _ | {let marker = __rtic_internal_TIMER_QUEUE_MARKER . get () . read () ; let nr = rtic :: export :: NotReady {instant , index , task : SCHED_T :: display , marker ,} ; __rtic_internal_TIMER_QUEUE_MARKER . get_mut () . write (__rtic_internal_TIMER_QUEUE_MARKER . get () . read () . wrapping_add (1)) ; let tq = & mut * __rtic_internal_TQ_MyMonotonic . get_mut () ; tq . enqueue_unchecked (nr , || core :: mem :: transmute :: < _ , rtic :: export :: SYST > (()) . enable_interrupt () , || rtic :: export :: SCB :: set_pendst () , (& mut * __rtic_internal_MONOTONIC_STORAGE_MyMonotonic . get_mut ()) . as_mut ()) ; Ok (display :: MyMonotonic :: SpawnHandle {marker})})} else {Err (input)}}} # [allow (non_snake_case)] # [doc = " Software task"] pub mod display {# [doc (inline)] pub use super :: __rtic_internal_displayLocalResources as LocalResources ; # [doc (inline)] pub use super :: __rtic_internal_displaySharedResources as SharedResources ; # [doc (inline)] pub use super :: __rtic_internal_display_Context as Context ; # [doc (inline)] pub use super :: __rtic_internal_display_spawn as spawn ; pub use MyMonotonic :: spawn_after ; pub use MyMonotonic :: spawn_at ; pub use MyMonotonic :: SpawnHandle ; # [doc (hidden)] pub mod MyMonotonic {pub use super :: super :: __rtic_internal_display_MyMonotonic_spawn_after as spawn_after ; pub use super :: super :: __rtic_internal_display_MyMonotonic_spawn_at as spawn_at ; pub use super :: super :: __rtic_internal_display_MyMonotonic_SpawnHandle as SpawnHandle ;}} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = " Local resources `screensaver` has access to"] pub struct __rtic_internal_screensaverLocalResources < 'a > {# [doc = " Local resource `last_changes`"] pub last_changes : & 'a mut u32 , # [doc = " Local resource `offset`"] pub offset : & 'a mut i32 ,} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = " Shared resources `screensaver` has access to"] pub struct __rtic_internal_screensaverSharedResources < 'a > {# [doc = " Resource proxy resource `changes`. Use method `.lock()` to gain access"] pub changes : shared_resources :: changes_that_needs_to_be_locked < 'a > , # [doc = " Shared resource `pool`"] pub pool : & 'a Pool < Image > , # [doc = " Resource proxy resource `next_image`. Use method `.lock()` to gain access"] pub next_image : shared_resources :: next_image_that_needs_to_be_locked < 'a > ,} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_screensaver_Context < 'a > {# [doc = r" Local Resources this task has access to"] pub local : screensaver :: LocalResources < 'a > , # [doc = r" Shared Resources this task has access to"] pub shared : screensaver :: SharedResources < 'a > ,} impl < 'a > __rtic_internal_screensaver_Context < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_screensaver_Context {local : screensaver :: LocalResources :: new () , shared : screensaver :: SharedResources :: new (priority) ,}}} # [doc = r" Spawns the task directly"] pub fn __rtic_internal_screensaver_spawn (_0 : Instant ,) -> Result < () , Instant > {let input = _0 ; unsafe {if let Some (index) = rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_screensaver_FQ . get_mut ()) . dequeue ()) {(& mut * __rtic_internal_screensaver_INPUTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (input) ; rtic :: export :: interrupt :: free (| _ | {(& mut * __rtic_internal_P1_RQ . get_mut ()) . enqueue_unchecked ((P1_T :: screensaver , index)) ;}) ; rtic :: pend (pac :: interrupt :: USART3) ; Ok (())} else {Err (input)}}} # [doc (hidden)] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_screensaver_MyMonotonic_SpawnHandle {# [doc (hidden)] marker : u32 ,} impl core :: fmt :: Debug for __rtic_internal_screensaver_MyMonotonic_SpawnHandle {# [doc (hidden)] fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result {f . debug_struct ("MyMonotonic::SpawnHandle") . finish ()}} impl __rtic_internal_screensaver_MyMonotonic_SpawnHandle {pub fn cancel (self) -> Result < Instant , () > {rtic :: export :: interrupt :: free (| _ | unsafe {let tq = & mut * __rtic_internal_TQ_MyMonotonic . get_mut () ; if let Some ((_task , index)) = tq . cancel_marker (self . marker) {let msg = (& * __rtic_internal_screensaver_INPUTS . get ()) . get_unchecked (usize :: from (index)) . as_ptr () . read () ; (& mut * __rtic_internal_screensaver_FQ . get_mut ()) . split () . 0 . enqueue_unchecked (index) ; Ok (msg)} else {Err (())}})} # [doc = r" Reschedule after "] # [inline] pub fn reschedule_after (self , duration : < MyMonotonic as rtic :: Monotonic > :: Duration) -> Result < Self , () > {self . reschedule_at (monotonics :: MyMonotonic :: now () + duration)} # [doc = r" Reschedule at "] pub fn reschedule_at (self , instant : < MyMonotonic as rtic :: Monotonic > :: Instant) -> Result < Self , () > {rtic :: export :: interrupt :: free (| _ | unsafe {let marker = __rtic_internal_TIMER_QUEUE_MARKER . get () . read () ; __rtic_internal_TIMER_QUEUE_MARKER . get_mut () . write (marker . wrapping_add (1)) ; let tq = (& mut * __rtic_internal_TQ_MyMonotonic . get_mut ()) ; tq . update_marker (self . marker , marker , instant , || rtic :: export :: SCB :: set_pendst ()) . map (| _ | screensaver :: MyMonotonic :: SpawnHandle {marker})})}} # [doc = r" Spawns the task after a set duration relative to the current time"] # [doc = r""] # [doc = r" This will use the time `Instant::new(0)` as baseline if called in `#[init]`,"] # [doc = r" so if you use a non-resetable timer use `spawn_at` when in `#[init]`"] # [allow (non_snake_case)] pub fn __rtic_internal_screensaver_MyMonotonic_spawn_after (duration : < MyMonotonic as rtic :: Monotonic > :: Duration , _0 : Instant) -> Result < screensaver :: MyMonotonic :: SpawnHandle , Instant > {let instant = monotonics :: MyMonotonic :: now () ; __rtic_internal_screensaver_MyMonotonic_spawn_at (instant + duration , _0)} # [doc = r" Spawns the task at a fixed time instant"] # [allow (non_snake_case)] pub fn __rtic_internal_screensaver_MyMonotonic_spawn_at (instant : < MyMonotonic as rtic :: Monotonic > :: Instant , _0 : Instant) -> Result < screensaver :: MyMonotonic :: SpawnHandle , Instant > {unsafe {let input = _0 ; if let Some (index) = rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_screensaver_FQ . get_mut ()) . dequeue ()) {(& mut * __rtic_internal_screensaver_INPUTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (input) ; (& mut * __rtic_internal_screensaver_MyMonotonic_INSTANTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (instant) ; rtic :: export :: interrupt :: free (| _ | {let marker = __rtic_internal_TIMER_QUEUE_MARKER . get () . read () ; let nr = rtic :: export :: NotReady {instant , index , task : SCHED_T :: screensaver , marker ,} ; __rtic_internal_TIMER_QUEUE_MARKER . get_mut () . write (__rtic_internal_TIMER_QUEUE_MARKER . get () . read () . wrapping_add (1)) ; let tq = & mut * __rtic_internal_TQ_MyMonotonic . get_mut () ; tq . enqueue_unchecked (nr , || core :: mem :: transmute :: < _ , rtic :: export :: SYST > (()) . enable_interrupt () , || rtic :: export :: SCB :: set_pendst () , (& mut * __rtic_internal_MONOTONIC_STORAGE_MyMonotonic . get_mut ()) . as_mut ()) ; Ok (screensaver :: MyMonotonic :: SpawnHandle {marker})})} else {Err (input)}}} # [allow (non_snake_case)] # [doc = " Software task"] pub mod screensaver {# [doc (inline)] pub use super :: __rtic_internal_screensaverLocalResources as LocalResources ; # [doc (inline)] pub use super :: __rtic_internal_screensaverSharedResources as SharedResources ; # [doc (inline)] pub use super :: __rtic_internal_screensaver_Context as Context ; # [doc (inline)] pub use super :: __rtic_internal_screensaver_spawn as spawn ; pub use MyMonotonic :: spawn_after ; pub use MyMonotonic :: spawn_at ; pub use MyMonotonic :: SpawnHandle ; # [doc (hidden)] pub mod MyMonotonic {pub use super :: super :: __rtic_internal_screensaver_MyMonotonic_spawn_after as spawn_after ; pub use super :: super :: __rtic_internal_screensaver_MyMonotonic_spawn_at as spawn_at ; pub use super :: super :: __rtic_internal_screensaver_MyMonotonic_SpawnHandle as SpawnHandle ;}} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [doc = " Shared resources `notice_change` has access to"] pub struct __rtic_internal_notice_changeSharedResources < 'a > {# [doc = " Resource proxy resource `changes`. Use method `.lock()` to gain access"] pub changes : shared_resources :: changes_that_needs_to_be_locked < 'a > ,} # [doc = r" Execution context"] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_notice_change_Context < 'a > {# [doc = r" Shared Resources this task has access to"] pub shared : notice_change :: SharedResources < 'a > ,} impl < 'a > __rtic_internal_notice_change_Context < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_notice_change_Context {shared : notice_change :: SharedResources :: new (priority) ,}}} # [doc = r" Spawns the task directly"] pub fn __rtic_internal_notice_change_spawn () -> Result < () , () > {let input = () ; unsafe {if let Some (index) = rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_notice_change_FQ . get_mut ()) . dequeue ()) {(& mut * __rtic_internal_notice_change_INPUTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (input) ; rtic :: export :: interrupt :: free (| _ | {(& mut * __rtic_internal_P1_RQ . get_mut ()) . enqueue_unchecked ((P1_T :: notice_change , index)) ;}) ; rtic :: pend (pac :: interrupt :: USART3) ; Ok (())} else {Err (input)}}} # [doc (hidden)] # [allow (non_snake_case)] # [allow (non_camel_case_types)] pub struct __rtic_internal_notice_change_MyMonotonic_SpawnHandle {# [doc (hidden)] marker : u32 ,} impl core :: fmt :: Debug for __rtic_internal_notice_change_MyMonotonic_SpawnHandle {# [doc (hidden)] fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result {f . debug_struct ("MyMonotonic::SpawnHandle") . finish ()}} impl __rtic_internal_notice_change_MyMonotonic_SpawnHandle {pub fn cancel (self) -> Result < () , () > {rtic :: export :: interrupt :: free (| _ | unsafe {let tq = & mut * __rtic_internal_TQ_MyMonotonic . get_mut () ; if let Some ((_task , index)) = tq . cancel_marker (self . marker) {let msg = (& * __rtic_internal_notice_change_INPUTS . get ()) . get_unchecked (usize :: from (index)) . as_ptr () . read () ; (& mut * __rtic_internal_notice_change_FQ . get_mut ()) . split () . 0 . enqueue_unchecked (index) ; Ok (msg)} else {Err (())}})} # [doc = r" Reschedule after "] # [inline] pub fn reschedule_after (self , duration : < MyMonotonic as rtic :: Monotonic > :: Duration) -> Result < Self , () > {self . reschedule_at (monotonics :: MyMonotonic :: now () + duration)} # [doc = r" Reschedule at "] pub fn reschedule_at (self , instant : < MyMonotonic as rtic :: Monotonic > :: Instant) -> Result < Self , () > {rtic :: export :: interrupt :: free (| _ | unsafe {let marker = __rtic_internal_TIMER_QUEUE_MARKER . get () . read () ; __rtic_internal_TIMER_QUEUE_MARKER . get_mut () . write (marker . wrapping_add (1)) ; let tq = (& mut * __rtic_internal_TQ_MyMonotonic . get_mut ()) ; tq . update_marker (self . marker , marker , instant , || rtic :: export :: SCB :: set_pendst ()) . map (| _ | notice_change :: MyMonotonic :: SpawnHandle {marker})})}} # [doc = r" Spawns the task after a set duration relative to the current time"] # [doc = r""] # [doc = r" This will use the time `Instant::new(0)` as baseline if called in `#[init]`,"] # [doc = r" so if you use a non-resetable timer use `spawn_at` when in `#[init]`"] # [allow (non_snake_case)] pub fn __rtic_internal_notice_change_MyMonotonic_spawn_after (duration : < MyMonotonic as rtic :: Monotonic > :: Duration) -> Result < notice_change :: MyMonotonic :: SpawnHandle , () > {let instant = monotonics :: MyMonotonic :: now () ; __rtic_internal_notice_change_MyMonotonic_spawn_at (instant + duration)} # [doc = r" Spawns the task at a fixed time instant"] # [allow (non_snake_case)] pub fn __rtic_internal_notice_change_MyMonotonic_spawn_at (instant : < MyMonotonic as rtic :: Monotonic > :: Instant) -> Result < notice_change :: MyMonotonic :: SpawnHandle , () > {unsafe {let input = () ; if let Some (index) = rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_notice_change_FQ . get_mut ()) . dequeue ()) {(& mut * __rtic_internal_notice_change_INPUTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (input) ; (& mut * __rtic_internal_notice_change_MyMonotonic_INSTANTS . get_mut ()) . get_unchecked_mut (usize :: from (index)) . as_mut_ptr () . write (instant) ; rtic :: export :: interrupt :: free (| _ | {let marker = __rtic_internal_TIMER_QUEUE_MARKER . get () . read () ; let nr = rtic :: export :: NotReady {instant , index , task : SCHED_T :: notice_change , marker ,} ; __rtic_internal_TIMER_QUEUE_MARKER . get_mut () . write (__rtic_internal_TIMER_QUEUE_MARKER . get () . read () . wrapping_add (1)) ; let tq = & mut * __rtic_internal_TQ_MyMonotonic . get_mut () ; tq . enqueue_unchecked (nr , || core :: mem :: transmute :: < _ , rtic :: export :: SYST > (()) . enable_interrupt () , || rtic :: export :: SCB :: set_pendst () , (& mut * __rtic_internal_MONOTONIC_STORAGE_MyMonotonic . get_mut ()) . as_mut ()) ; Ok (notice_change :: MyMonotonic :: SpawnHandle {marker})})} else {Err (input)}}} # [allow (non_snake_case)] # [doc = " Software task"] pub mod notice_change {# [doc (inline)] pub use super :: __rtic_internal_notice_changeSharedResources as SharedResources ; # [doc (inline)] pub use super :: __rtic_internal_notice_change_Context as Context ; # [doc (inline)] pub use super :: __rtic_internal_notice_change_spawn as spawn ; pub use MyMonotonic :: spawn_after ; pub use MyMonotonic :: spawn_at ; pub use MyMonotonic :: SpawnHandle ; # [doc (hidden)] pub mod MyMonotonic {pub use super :: super :: __rtic_internal_notice_change_MyMonotonic_spawn_after as spawn_after ; pub use super :: super :: __rtic_internal_notice_change_MyMonotonic_spawn_at as spawn_at ; pub use super :: super :: __rtic_internal_notice_change_MyMonotonic_SpawnHandle as SpawnHandle ;}} # [doc = r" App module"] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic0"] static __rtic_internal_shared_resource_next_image : rtic :: RacyCell < core :: mem :: MaybeUninit < Option < Box < Image > > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; impl < 'a > rtic :: Mutex for shared_resources :: next_image_that_needs_to_be_locked < 'a > {type T = Option < Box < Image > > ; # [inline (always)] fn lock < RTIC_INTERNAL_R > (& mut self , f : impl FnOnce (& mut Option < Box < Image > >) -> RTIC_INTERNAL_R) -> RTIC_INTERNAL_R {# [doc = r" Priority ceiling"] const CEILING : u8 = 2u8 ; unsafe {rtic :: export :: lock (__rtic_internal_shared_resource_next_image . get_mut () as * mut _ , self . priority () , CEILING , pac :: NVIC_PRIO_BITS , & __rtic_internal_MASKS , f ,)}}} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic1"] static __rtic_internal_shared_resource_pool : rtic :: RacyCell < core :: mem :: MaybeUninit < Pool < Image > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; impl < 'a > rtic :: Mutex for shared_resources :: pool_that_needs_to_be_locked < 'a > {type T = Pool < Image > ; # [inline (always)] fn lock < RTIC_INTERNAL_R > (& mut self , f : impl FnOnce (& mut Pool < Image >) -> RTIC_INTERNAL_R) -> RTIC_INTERNAL_R {# [doc = r" Priority ceiling"] const CEILING : u8 = 2u8 ; unsafe {rtic :: export :: lock (__rtic_internal_shared_resource_pool . get_mut () as * mut _ , self . priority () , CEILING , pac :: NVIC_PRIO_BITS , & __rtic_internal_MASKS , f ,)}}} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic2"] static __rtic_internal_shared_resource_changes : rtic :: RacyCell < core :: mem :: MaybeUninit < u32 >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; impl < 'a > rtic :: Mutex for shared_resources :: changes_that_needs_to_be_locked < 'a > {type T = u32 ; # [inline (always)] fn lock < RTIC_INTERNAL_R > (& mut self , f : impl FnOnce (& mut u32) -> RTIC_INTERNAL_R) -> RTIC_INTERNAL_R {# [doc = r" Priority ceiling"] const CEILING : u8 = 1u8 ; unsafe {rtic :: export :: lock (__rtic_internal_shared_resource_changes . get_mut () as * mut _ , self . priority () , CEILING , pac :: NVIC_PRIO_BITS , & __rtic_internal_MASKS , f ,)}}} # [doc (hidden)] # [allow (non_upper_case_globals)] const __rtic_internal_MASK_CHUNKS : usize = rtic :: export :: compute_mask_chunks ([pac :: Interrupt :: USART3 as u32 , pac :: Interrupt :: USART2 as u32 , pac :: Interrupt :: USART1 as u32]) ; # [doc (hidden)] # [allow (non_upper_case_globals)] const __rtic_internal_MASKS : [rtic :: export :: Mask < __rtic_internal_MASK_CHUNKS > ; 3] = [rtic :: export :: create_mask ([pac :: Interrupt :: USART3 as u32 , pac :: Interrupt :: USART1 as u32]) , rtic :: export :: create_mask ([pac :: Interrupt :: USART2 as u32]) , rtic :: export :: create_mask ([])] ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic3"] static __rtic_internal_local_resource_matrix : rtic :: RacyCell < core :: mem :: MaybeUninit < Matrix >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic4"] static __rtic_internal_local_resource_usart1_rx : rtic :: RacyCell < core :: mem :: MaybeUninit < Rx < USART1 > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic5"] static __rtic_internal_local_resource_current_image : rtic :: RacyCell < core :: mem :: MaybeUninit < Box < Image > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] # [link_section = ".uninit.rtic6"] static __rtic_internal_local_resource_rx_image : rtic :: RacyCell < core :: mem :: MaybeUninit < Box < Image > >> = rtic :: RacyCell :: new (core :: mem :: MaybeUninit :: uninit ()) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_local_receive_byte_next_pos : rtic :: RacyCell < usize > = rtic :: RacyCell :: new (0) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_local_display_next_line : rtic :: RacyCell < usize > = rtic :: RacyCell :: new (0) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_local_screensaver_last_changes : rtic :: RacyCell < u32 > = rtic :: RacyCell :: new (0) ; # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_local_screensaver_offset : rtic :: RacyCell < i32 > = rtic :: RacyCell :: new (20) ; # [allow (non_snake_case)] # [no_mangle] # [doc = " User HW task ISR trampoline for receive_byte"] unsafe fn USART1 () {const PRIORITY : u8 = 1u8 ; rtic :: export :: run (PRIORITY , || {receive_byte (receive_byte :: Context :: new (& rtic :: export :: Priority :: new (PRIORITY)))}) ;} impl < 'a > __rtic_internal_receive_byteLocalResources < 'a > {# [inline (always)] # [doc (hidden)] pub unsafe fn new () -> Self {__rtic_internal_receive_byteLocalResources {usart1_rx : & mut * (& mut * __rtic_internal_local_resource_usart1_rx . get_mut ()) . as_mut_ptr () , rx_image : & mut * (& mut * __rtic_internal_local_resource_rx_image . get_mut ()) . as_mut_ptr () , next_pos : & mut * __rtic_internal_local_receive_byte_next_pos . get_mut () ,}}} impl < 'a > __rtic_internal_receive_byteSharedResources < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_receive_byteSharedResources {# [doc (hidden)] next_image : shared_resources :: next_image_that_needs_to_be_locked :: new (priority) , # [doc = " Non-exclusive access resource `pool`"] pool : & * (& * __rtic_internal_shared_resource_pool . get ()) . as_ptr () ,}}} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_display_FQ : rtic :: RacyCell < rtic :: export :: SCFQ < 2 > > = rtic :: RacyCell :: new (rtic :: export :: Queue :: new ()) ; # [link_section = ".uninit.rtic7"] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_display_MyMonotonic_INSTANTS : rtic :: RacyCell < [core :: mem :: MaybeUninit << DwtSystick < 80_000_000 > as rtic :: Monotonic > :: Instant > ; 1] > = rtic :: RacyCell :: new ([core :: mem :: MaybeUninit :: uninit () ,]) ; # [link_section = ".uninit.rtic8"] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_display_INPUTS : rtic :: RacyCell < [core :: mem :: MaybeUninit < Instant > ; 1] > = rtic :: RacyCell :: new ([core :: mem :: MaybeUninit :: uninit () ,]) ; impl < 'a > __rtic_internal_displayLocalResources < 'a > {# [inline (always)] # [doc (hidden)] pub unsafe fn new () -> Self {__rtic_internal_displayLocalResources {matrix : & mut * (& mut * __rtic_internal_local_resource_matrix . get_mut ()) . as_mut_ptr () , current_image : & mut * (& mut * __rtic_internal_local_resource_current_image . get_mut ()) . as_mut_ptr () , next_line : & mut * __rtic_internal_local_display_next_line . get_mut () ,}}} impl < 'a > __rtic_internal_displaySharedResources < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_displaySharedResources {# [doc (hidden)] next_image : shared_resources :: next_image_that_needs_to_be_locked :: new (priority) , # [doc = " Non-exclusive access resource `pool`"] pool : & * (& * __rtic_internal_shared_resource_pool . get ()) . as_ptr () ,}}} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_screensaver_FQ : rtic :: RacyCell < rtic :: export :: SCFQ < 2 > > = rtic :: RacyCell :: new (rtic :: export :: Queue :: new ()) ; # [link_section = ".uninit.rtic9"] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_screensaver_MyMonotonic_INSTANTS : rtic :: RacyCell < [core :: mem :: MaybeUninit << DwtSystick < 80_000_000 > as rtic :: Monotonic > :: Instant > ; 1] > = rtic :: RacyCell :: new ([core :: mem :: MaybeUninit :: uninit () ,]) ; # [link_section = ".uninit.rtic10"] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_screensaver_INPUTS : rtic :: RacyCell < [core :: mem :: MaybeUninit < Instant > ; 1] > = rtic :: RacyCell :: new ([core :: mem :: MaybeUninit :: uninit () ,]) ; impl < 'a > __rtic_internal_screensaverLocalResources < 'a > {# [inline (always)] # [doc (hidden)] pub unsafe fn new () -> Self {__rtic_internal_screensaverLocalResources {last_changes : & mut * __rtic_internal_local_screensaver_last_changes . get_mut () , offset : & mut * __rtic_internal_local_screensaver_offset . get_mut () ,}}} impl < 'a > __rtic_internal_screensaverSharedResources < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_screensaverSharedResources {# [doc (hidden)] changes : shared_resources :: changes_that_needs_to_be_locked :: new (priority) , # [doc = " Non-exclusive access resource `pool`"] pool : & * (& * __rtic_internal_shared_resource_pool . get ()) . as_ptr () , # [doc (hidden)] next_image : shared_resources :: next_image_that_needs_to_be_locked :: new (priority) ,}}} # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_notice_change_FQ : rtic :: RacyCell < rtic :: export :: SCFQ < 2 > > = rtic :: RacyCell :: new (rtic :: export :: Queue :: new ()) ; # [link_section = ".uninit.rtic11"] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_notice_change_MyMonotonic_INSTANTS : rtic :: RacyCell < [core :: mem :: MaybeUninit << DwtSystick < 80_000_000 > as rtic :: Monotonic > :: Instant > ; 1] > = rtic :: RacyCell :: new ([core :: mem :: MaybeUninit :: uninit () ,]) ; # [link_section = ".uninit.rtic12"] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] # [doc (hidden)] static __rtic_internal_notice_change_INPUTS : rtic :: RacyCell < [core :: mem :: MaybeUninit < () > ; 1] > = rtic :: RacyCell :: new ([core :: mem :: MaybeUninit :: uninit () ,]) ; impl < 'a > __rtic_internal_notice_changeSharedResources < 'a > {# [doc (hidden)] # [inline (always)] pub unsafe fn new (priority : & 'a rtic :: export :: Priority) -> Self {__rtic_internal_notice_changeSharedResources {# [doc (hidden)] changes : shared_resources :: changes_that_needs_to_be_locked :: new (priority) ,}}} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [derive (Clone , Copy)] # [doc (hidden)] pub enum P1_T {notice_change , screensaver ,} # [doc (hidden)] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] static __rtic_internal_P1_RQ : rtic :: RacyCell < rtic :: export :: SCRQ < P1_T , 3 > > = rtic :: RacyCell :: new (rtic :: export :: Queue :: new ()) ; # [allow (non_snake_case)] # [doc = "Interrupt handler to dispatch tasks at priority 1"] # [no_mangle] unsafe fn USART3 () {# [doc = r" The priority of this interrupt handler"] const PRIORITY : u8 = 1u8 ; rtic :: export :: run (PRIORITY , || {while let Some ((task , index)) = (& mut * __rtic_internal_P1_RQ . get_mut ()) . split () . 1 . dequeue () {match task {P1_T :: notice_change => {let () = (& * __rtic_internal_notice_change_INPUTS . get ()) . get_unchecked (usize :: from (index)) . as_ptr () . read () ; (& mut * __rtic_internal_notice_change_FQ . get_mut ()) . split () . 0 . enqueue_unchecked (index) ; let priority = & rtic :: export :: Priority :: new (PRIORITY) ; notice_change (notice_change :: Context :: new (priority))} P1_T :: screensaver => {let _0 = (& * __rtic_internal_screensaver_INPUTS . get ()) . get_unchecked (usize :: from (index)) . as_ptr () . read () ; (& mut * __rtic_internal_screensaver_FQ . get_mut ()) . split () . 0 . enqueue_unchecked (index) ; let priority = & rtic :: export :: Priority :: new (PRIORITY) ; screensaver (screensaver :: Context :: new (priority) , _0)}}}}) ;} # [allow (non_snake_case)] # [allow (non_camel_case_types)] # [derive (Clone , Copy)] # [doc (hidden)] pub enum P2_T {display ,} # [doc (hidden)] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] static __rtic_internal_P2_RQ : rtic :: RacyCell < rtic :: export :: SCRQ < P2_T , 2 > > = rtic :: RacyCell :: new (rtic :: export :: Queue :: new ()) ; # [allow (non_snake_case)] # [doc = "Interrupt handler to dispatch tasks at priority 2"] # [no_mangle] unsafe fn USART2 () {# [doc = r" The priority of this interrupt handler"] const PRIORITY : u8 = 2u8 ; rtic :: export :: run (PRIORITY , || {while let Some ((task , index)) = (& mut * __rtic_internal_P2_RQ . get_mut ()) . split () . 1 . dequeue () {match task {P2_T :: display => {let _0 = (& * __rtic_internal_display_INPUTS . get ()) . get_unchecked (usize :: from (index)) . as_ptr () . read () ; (& mut * __rtic_internal_display_FQ . get_mut ()) . split () . 0 . enqueue_unchecked (index) ; let priority = & rtic :: export :: Priority :: new (PRIORITY) ; display (display :: Context :: new (priority) , _0)}}}}) ;} # [doc (hidden)] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] static __rtic_internal_TIMER_QUEUE_MARKER : rtic :: RacyCell < u32 > = rtic :: RacyCell :: new (0) ; # [doc (hidden)] # [allow (non_camel_case_types)] # [derive (Clone , Copy)] pub enum SCHED_T {display , screensaver , notice_change ,} # [doc (hidden)] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] static __rtic_internal_TQ_MyMonotonic : rtic :: RacyCell < rtic :: export :: TimerQueue < DwtSystick < 80_000_000 > , SCHED_T , 3 > > = rtic :: RacyCell :: new (rtic :: export :: TimerQueue (rtic :: export :: SortedLinkedList :: new_u16 ())) ; # [doc (hidden)] # [allow (non_camel_case_types)] # [allow (non_upper_case_globals)] static __rtic_internal_MONOTONIC_STORAGE_MyMonotonic : rtic :: RacyCell < Option < DwtSystick < 80_000_000 > >> = rtic :: RacyCell :: new (None) ; # [no_mangle] # [allow (non_snake_case)] unsafe fn SysTick () {while let Some ((task , index)) = rtic :: export :: interrupt :: free (| _ | if let Some (mono) = (& mut * __rtic_internal_MONOTONIC_STORAGE_MyMonotonic . get_mut ()) . as_mut () {(& mut * __rtic_internal_TQ_MyMonotonic . get_mut ()) . dequeue (|| core :: mem :: transmute :: < _ , rtic :: export :: SYST > (()) . disable_interrupt () , mono)} else {core :: hint :: unreachable_unchecked ()}) {match task {SCHED_T :: display => {rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_P2_RQ . get_mut ()) . split () . 0 . enqueue_unchecked ((P2_T :: display , index))) ; rtic :: pend (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART2) ;} SCHED_T :: screensaver => {rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_P1_RQ . get_mut ()) . split () . 0 . enqueue_unchecked ((P1_T :: screensaver , index))) ; rtic :: pend (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART3) ;} SCHED_T :: notice_change => {rtic :: export :: interrupt :: free (| _ | (& mut * __rtic_internal_P1_RQ . get_mut ()) . split () . 0 . enqueue_unchecked ((P1_T :: notice_change , index))) ; rtic :: pend (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART3) ;}}} rtic :: export :: interrupt :: free (| _ | if let Some (mono) = (& mut * __rtic_internal_MONOTONIC_STORAGE_MyMonotonic . get_mut ()) . as_mut () {mono . on_interrupt () ;}) ;} # [doc (hidden)] mod rtic_ext {use super :: * ; # [no_mangle] unsafe extern "C" fn main () -> ! {rtic :: export :: assert_send :: < Option < Box < Image > > > () ; rtic :: export :: assert_send :: < Pool < Image > > () ; rtic :: export :: assert_send :: < u32 > () ; rtic :: export :: assert_send :: < Matrix > () ; rtic :: export :: assert_send :: < Rx < USART1 > > () ; rtic :: export :: assert_send :: < Box < Image > > () ; rtic :: export :: assert_send :: < Instant > () ; rtic :: export :: assert_sync :: < Pool < Image > > () ; rtic :: export :: assert_monotonic :: < DwtSystick < 80_000_000 > > () ; const _CONST_CHECK : () = {if ! rtic :: export :: have_basepri () {if (pac :: Interrupt :: USART1 as usize) >= (__rtic_internal_MASK_CHUNKS * 32) {:: core :: panic ! ("An interrupt out of range is used while in armv6 or armv8m.base") ;}} else {}} ; let _ = _CONST_CHECK ; rtic :: export :: interrupt :: disable () ; (0 .. 1u8) . for_each (| i | (& mut * __rtic_internal_display_FQ . get_mut ()) . enqueue_unchecked (i)) ; (0 .. 1u8) . for_each (| i | (& mut * __rtic_internal_screensaver_FQ . get_mut ()) . enqueue_unchecked (i)) ; (0 .. 1u8) . for_each (| i | (& mut * __rtic_internal_notice_change_FQ . get_mut ()) . enqueue_unchecked (i)) ; let mut core : rtic :: export :: Peripherals = rtic :: export :: Peripherals :: steal () . into () ; let _ = you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART2 ; let _ = you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART3 ; const _ : () = if (1 << pac :: NVIC_PRIO_BITS) < 1u8 as usize {:: core :: panic ! ("Maximum priority used by interrupt vector 'USART3' is more than supported by hardware") ;} ; core . NVIC . set_priority (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART3 , rtic :: export :: logical2hw (1u8 , pac :: NVIC_PRIO_BITS) ,) ; rtic :: export :: NVIC :: unmask (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART3) ; const _ : () = if (1 << pac :: NVIC_PRIO_BITS) < 2u8 as usize {:: core :: panic ! ("Maximum priority used by interrupt vector 'USART2' is more than supported by hardware") ;} ; core . NVIC . set_priority (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART2 , rtic :: export :: logical2hw (2u8 , pac :: NVIC_PRIO_BITS) ,) ; rtic :: export :: NVIC :: unmask (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART2) ; const _ : () = if (1 << pac :: NVIC_PRIO_BITS) < 1u8 as usize {:: core :: panic ! ("Maximum priority used by interrupt vector 'USART1' is more than supported by hardware") ;} ; core . NVIC . set_priority (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART1 , rtic :: export :: logical2hw (1u8 , pac :: NVIC_PRIO_BITS) ,) ; rtic :: export :: NVIC :: unmask (you_must_enable_the_rt_feature_for_the_pac_in_your_cargo_toml :: interrupt :: USART1) ; const _ : () = if (1 << pac :: NVIC_PRIO_BITS) < (1 << pac :: NVIC_PRIO_BITS) as usize {:: core :: panic ! ("Maximum priority used by monotonic 'MyMonotonic' is more than supported by hardware") ;} ; core . SCB . set_priority (rtic :: export :: SystemHandler :: SysTick , rtic :: export :: logical2hw ((1 << pac :: NVIC_PRIO_BITS) , pac :: NVIC_PRIO_BITS) ,) ; if ! < DwtSystick < 80_000_000 > as rtic :: Monotonic > :: DISABLE_INTERRUPT_ON_EMPTY_QUEUE {core :: mem :: transmute :: < _ , rtic :: export :: SYST > (()) . enable_interrupt () ;} # [inline (never)] fn __rtic_init_resources < F > (f : F) where F : FnOnce () {f () ;} __rtic_init_resources (|| {let (shared_resources , local_resources , mut monotonics) = init (init :: Context :: new (core . into ())) ; __rtic_internal_shared_resource_next_image . get_mut () . write (core :: mem :: MaybeUninit :: new (shared_resources . next_image)) ; __rtic_internal_shared_resource_pool . get_mut () . write (core :: mem :: MaybeUninit :: new (shared_resources . pool)) ; __rtic_internal_shared_resource_changes . get_mut () . write (core :: mem :: MaybeUninit :: new (shared_resources . changes)) ; __rtic_internal_local_resource_matrix . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . matrix)) ; __rtic_internal_local_resource_usart1_rx . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . usart1_rx)) ; __rtic_internal_local_resource_current_image . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . current_image)) ; __rtic_internal_local_resource_rx_image . get_mut () . write (core :: mem :: MaybeUninit :: new (local_resources . rx_image)) ; monotonics . 0 . reset () ; __rtic_internal_MONOTONIC_STORAGE_MyMonotonic . get_mut () . write (Some (monotonics . 0)) ; rtic :: export :: interrupt :: enable () ;}) ; idle (idle :: Context :: new (& rtic :: export :: Priority :: new (0)))}}}